/**
 * File Categorization Utilities
 * 
 * Categorizes files for template restoration operations.
 * Implements requirements 2.1 and 2.2 for file categorization system.
 */

import { stat } from 'node:fs/promises';
import { join, basename, extname } from 'node:path';
import { FSUtils } from './fs-utils.js';

export class FileCategorizer {
  constructor() {
    this.categories = {
      // Files that are generated by ecosystem tools and can be regenerated
      generated: {
        files: [
          'package-lock.json',
          'yarn.lock', 
          'pnpm-lock.yaml',
          'bun.lockb',
          'composer.lock',
          'Pipfile.lock',
          'poetry.lock'
        ],
        directories: [
          'node_modules',
          'dist',
          'build',
          '.next',
          '.nuxt',
          '.output',
          'coverage',
          '.nyc_output',
          '.cache',
          'tmp',
          'temp',
          '.wrangler',
          '__pycache__',
          '.pytest_cache',
          'vendor'
        ],
        storeContent: false,
        regenerationCommands: {
          'package-lock.json': 'npm install',
          'yarn.lock': 'yarn install',
          'pnpm-lock.yaml': 'pnpm install',
          'bun.lockb': 'bun install',
          'node_modules': 'npm install',
          'dist': 'npm run build',
          'build': 'npm run build',
          '.next': 'npm run build',
          '.nuxt': 'npm run build',
          'coverage': 'npm run test:coverage',
          'vendor': 'composer install',
          '__pycache__': 'python -m py_compile'
        }
      },

      // Files created by users that contain instance-specific data
      userCreated: {
        files: [
          '.env',
          '.env.local',
          '.env.development',
          '.env.production',
          '.env.test',
          '.dev.vars',
          'config.local.json',
          'settings.local.json',
          '.vscode/settings.json',
          '.idea/workspace.xml'
        ],
        directories: [
          'uploads',
          'storage',
          'logs',
          'data'
        ],
        storeContent: true,
        regenerationCommands: {}
      },

      // Files created by make-template that provide template functionality
      templateFiles: {
        files: [
          'template.json',
          '_setup.mjs',
          '.template-undo.json'
        ],
        directories: [],
        storeContent: false,
        action: 'preserve'
      },

      // Files that should be modified (placeholders replaced) but preserved
      modified: {
        files: [
          'package.json',
          'README.md',
          'wrangler.jsonc',
          'wrangler.json',
          'vite.config.js',
          'vite.config.ts',
          'webpack.config.js',
          'rollup.config.js',
          'tsconfig.json',
          'jsconfig.json',
          'index.html'
        ],
        directories: [],
        storeContent: true,
        action: 'restore-content'
      }
    };

    // File size thresholds for content storage decisions (in bytes)
    this.sizeThresholds = {
      maxContentStorage: 10 * 1024 * 1024, // 10MB - don't store content for files larger than this
      largeFileWarning: 1024 * 1024 // 1MB - warn about large files
    };
  }

  /**
   * Categorize a file or directory
   * @param {string} filePath - Path to the file or directory
   * @param {object} options - Categorization options
   * @returns {object} Categorization result
   */
  async categorizeFile(filePath, options = {}) {
    try {
      const fileName = basename(filePath);
      const stats = await FSUtils.stat(filePath);
      const isDirectory = stats.isDirectory();
      const fileSize = stats.size;

      // Check each category
      for (const [categoryName, categoryConfig] of Object.entries(this.categories)) {
        const matchResult = this.matchesCategory(filePath, fileName, isDirectory, categoryConfig);
        
        if (matchResult.matches) {
          const shouldStoreContent = this.shouldStoreContent(
            categoryConfig,
            fileSize,
            isDirectory,
            options
          );

          return {
            category: categoryName,
            path: filePath,
            fileName,
            isDirectory,
            fileSize,
            storeContent: shouldStoreContent,
            action: categoryConfig.action || this.getDefaultAction(categoryName),
            regenerationCommand: categoryConfig.regenerationCommands[fileName] || 
                               categoryConfig.regenerationCommands[filePath] || null,
            matchedPattern: matchResult.pattern,
            warnings: this.getWarnings(fileSize, shouldStoreContent)
          };
        }
      }

      // Default to user-created if no specific category matches
      const shouldStoreContent = this.shouldStoreContent(
        this.categories.userCreated,
        fileSize,
        isDirectory,
        options
      );

      return {
        category: 'userCreated',
        path: filePath,
        fileName,
        isDirectory,
        fileSize,
        storeContent: shouldStoreContent,
        action: 'restore-content',
        regenerationCommand: null,
        matchedPattern: 'default',
        warnings: this.getWarnings(fileSize, shouldStoreContent)
      };

    } catch (error) {
      throw new Error(`Failed to categorize file ${filePath}: ${error.message}`);
    }
  }

  /**
   * Check if a file matches a category
   * @param {string} filePath - Full file path
   * @param {string} fileName - Base file name
   * @param {boolean} isDirectory - Whether the path is a directory
   * @param {object} categoryConfig - Category configuration
   * @returns {object} Match result
   */
  matchesCategory(filePath, fileName, isDirectory, categoryConfig) {
    const targetList = isDirectory ? categoryConfig.directories : categoryConfig.files;
    
    for (const pattern of targetList) {
      if (this.matchesPattern(filePath, fileName, pattern)) {
        return { matches: true, pattern };
      }
    }
    
    return { matches: false, pattern: null };
  }

  /**
   * Check if a file matches a specific pattern
   * @param {string} filePath - Full file path
   * @param {string} fileName - Base file name
   * @param {string} pattern - Pattern to match against
   * @returns {boolean} Whether the file matches the pattern
   */
  matchesPattern(filePath, fileName, pattern) {
    // Exact match
    if (fileName === pattern || filePath === pattern) {
      return true;
    }

    // Directory pattern (ends with /)
    if (pattern.endsWith('/')) {
      const dirPattern = pattern.slice(0, -1);
      return fileName === dirPattern || filePath.includes(`/${dirPattern}/`) || filePath.endsWith(`/${dirPattern}`);
    }

    // Glob pattern with wildcards
    if (pattern.includes('*')) {
      const regex = new RegExp('^' + pattern.replace(/\*/g, '.*') + '$');
      return regex.test(fileName) || regex.test(filePath);
    }

    // Extension pattern
    if (pattern.startsWith('*.')) {
      const extension = pattern.slice(2);
      return fileName.endsWith(`.${extension}`);
    }

    // Path contains pattern
    return filePath.includes(pattern);
  }

  /**
   * Determine if content should be stored for a file
   * @param {object} categoryConfig - Category configuration
   * @param {number} fileSize - File size in bytes
   * @param {boolean} isDirectory - Whether the path is a directory
   * @param {object} options - Options
   * @returns {boolean} Whether to store content
   */
  shouldStoreContent(categoryConfig, fileSize, isDirectory, options = {}) {
    // Directories never store content
    if (isDirectory) {
      return false;
    }

    // Check category default
    if (!categoryConfig.storeContent) {
      return false;
    }

    // Check size threshold
    if (fileSize > this.sizeThresholds.maxContentStorage) {
      return false;
    }

    // Allow override via options
    if (options.forceStoreContent) {
      return true;
    }

    if (options.neverStoreContent) {
      return false;
    }

    return true;
  }

  /**
   * Get default action for a category
   * @param {string} categoryName - Category name
   * @returns {string} Default action
   */
  getDefaultAction(categoryName) {
    const defaultActions = {
      generated: 'regenerate',
      userCreated: 'restore-content',
      templateFiles: 'preserve',
      modified: 'restore-content'
    };

    return defaultActions[categoryName] || 'restore-content';
  }

  /**
   * Get warnings for a file categorization
   * @param {number} fileSize - File size in bytes
   * @param {boolean} storeContent - Whether content will be stored
   * @returns {string[]} Array of warning messages
   */
  getWarnings(fileSize, storeContent) {
    const warnings = [];

    if (fileSize > this.sizeThresholds.largeFileWarning && storeContent) {
      warnings.push(`Large file (${this.formatFileSize(fileSize)}) - content will be stored in undo log`);
    }

    if (fileSize > this.sizeThresholds.maxContentStorage) {
      warnings.push(`File too large (${this.formatFileSize(fileSize)}) - content will not be stored`);
    }

    return warnings;
  }

  /**
   * Format file size for display
   * @param {number} bytes - File size in bytes
   * @returns {string} Formatted file size
   */
  formatFileSize(bytes) {
    if (bytes < 1024) return `${bytes} B`;
    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
    if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
    return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;
  }

  /**
   * Categorize multiple files
   * @param {string[]} filePaths - Array of file paths
   * @param {object} options - Categorization options
   * @returns {object} Categorization results grouped by category
   */
  async categorizeFiles(filePaths, options = {}) {
    const results = {
      generated: [],
      userCreated: [],
      templateFiles: [],
      modified: [],
      errors: []
    };

    for (const filePath of filePaths) {
      try {
        const result = await this.categorizeFile(filePath, options);
        results[result.category].push(result);
      } catch (error) {
        results.errors.push({
          path: filePath,
          error: error.message
        });
      }
    }

    return results;
  }

  /**
   * Get categorization summary
   * @param {object} categorizedFiles - Result from categorizeFiles
   * @returns {object} Summary statistics
   */
  getCategorySummary(categorizedFiles) {
    const summary = {
      totalFiles: 0,
      totalSize: 0,
      contentStorageSize: 0,
      categories: {}
    };

    for (const [category, files] of Object.entries(categorizedFiles)) {
      if (category === 'errors') continue;

      const categorySize = files.reduce((sum, file) => sum + (file.fileSize || 0), 0);
      const contentSize = files
        .filter(file => file.storeContent)
        .reduce((sum, file) => sum + (file.fileSize || 0), 0);

      summary.categories[category] = {
        count: files.length,
        totalSize: categorySize,
        contentStorageSize: contentSize,
        files: files.map(f => f.path)
      };

      summary.totalFiles += files.length;
      summary.totalSize += categorySize;
      summary.contentStorageSize += contentSize;
    }

    return summary;
  }

  /**
   * Add custom categorization rules
   * @param {string} category - Category name
   * @param {object} rules - Rules to add
   */
  addCustomRules(category, rules) {
    if (!this.categories[category]) {
      this.categories[category] = {
        files: [],
        directories: [],
        storeContent: true,
        regenerationCommands: {}
      };
    }

    if (rules.files) {
      this.categories[category].files.push(...rules.files);
    }

    if (rules.directories) {
      this.categories[category].directories.push(...rules.directories);
    }

    if (rules.regenerationCommands) {
      Object.assign(this.categories[category].regenerationCommands, rules.regenerationCommands);
    }

    if (typeof rules.storeContent === 'boolean') {
      this.categories[category].storeContent = rules.storeContent;
    }
  }

  /**
   * Validate categorization rules
   * @returns {object} Validation result
   */
  validateRules() {
    const issues = [];
    const duplicates = new Set();

    // Check for duplicate patterns across categories
    for (const [categoryName, categoryConfig] of Object.entries(this.categories)) {
      const allPatterns = [...categoryConfig.files, ...categoryConfig.directories];
      
      for (const pattern of allPatterns) {
        if (duplicates.has(pattern)) {
          issues.push(`Duplicate pattern '${pattern}' found in category '${categoryName}'`);
        } else {
          duplicates.add(pattern);
        }
      }
    }

    return {
      valid: issues.length === 0,
      issues
    };
  }
}

export default FileCategorizer;